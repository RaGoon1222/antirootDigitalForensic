# Memory 분석
>*주로 윈도우에 관한 이야기만 다룬다.*  
포렌식에서 빼놓을 수 없는 메모리 분석에 대한 이야기이다.  
메모리에는 프로세스가 사용한 데이터와 프로세스 자체, 웹 브라우저를 통해 전송된 정보, 복호화된 데이터 등이 기록되어 있다.  
메모리 분석에 대한 연구는 (이 책 기준)현재진행형이므로 파일시스템 분석이나 레지스트리 분석과 비교할 때는 아직 부족하지만 시스템의 많은 정보를 알아낼 수 있으므로 메모리에 대해 반드시 알고 정보 활용 능력을 길러야 한다.

### 메모리 분석의 관심과 장점, 단점
1. 하드디스크에서 실행되지 않고 메모리상에서 바로 실행되는 악성코드의 존재  
이런 경우, 하드디스크를 이미지 파일로 만들어 분석한다 하더라도 악성 파일의 실행 원본 파일이나 흔적을 하드디스크에서 찾을 수 없으므로 메모리 분석이 필요하다.
2. 사용자 응용 프로그램의 프라이버시 보호 기능 강화  
요즘은 암호화나 개인정보보호 프로그램이 일반화되어 범용되어진다.  
이러한 프로그램들은 일반 사용자의 개인 파일들을 보호하지만, 시스템에 침투한 악성코드 또한 보호하는 경우가 발생한다.   
개인정보보호 프로그램이 악성코드 판별 기능이 없기 때문이다.   
이러한 상황에서 악성코드를 분석하려면 메모리 영역을 분석해야한다.  
실행 파일들은 메모리 영역에서는 복호화되어 실행되기 때문이다.  
3. [안티 포렌식(Anti Forensic)](https://en.wikipedia.org/wiki/Anti-computer_forensics)기술의 확산으로 하드 드라이브에 존재하고 있는 데이터의 무결성 불완전  
안티 포렌식 기술은 [루트킷](https://ko.wikipedia.org/wiki/%EB%A3%A8%ED%8A%B8%ED%82%B7)의 경우 나쁘다고 할 수 있지만 데이터 완전 삭제 기술 같은 경우, 일반 사용자들에게는 개인정보파일들을 유출되지 못하도록 하는 기술이기 때문에 좋다고 할 수도 있다.  
아무튼 루트킷이나 데이터 완전 삭제 기술의 경우 무결성을 저해하는 행위이기 때문에 하드디스크가 아닐 경우 메모리에서밖에 복구하지 못한다.  
메모리의 데이터도 완전하지는 않지만 그래도 수집하여 분석하는 것이 도움되기 때문에 메모리 영역을 분석해 데이터를 추출해야 한다.  

위와 같은 이유로 포렌식 관점의 메모리 분석 분야가 관심받기 시작했지만 (이 책 기준)아직까지는 발전 단계가 낮다.  
메모리 분석을 위한 선행 지식이 방대하고 구조는 운영체제마다 다른데다 세부적으로 패치에 따라 달라지기 때문이다. 
 
Live Response에 메모리 분석 과정이 포함될 수 있는데 이는 메모리 분석을 통해 얻는 정보가 대부분 Live Response 정보와 일치하기 때문이다.  
그렇기에 Live Response 과정에 메모리 분석을 넣는 것은 조사관 판단에 달려 있다.  
얻어지는 정보가 비슷하거나 일치한다고 해서 서로 대체하거는 것이 불가능하다.  
Live Response는 메모리 분석과 비교하였을 때 다음과 같은 단점을 지니고 있다.  

1. 도구의 신뢰성 저하  
Live Response 도구들은 대부분 윈도우에서 기본적으로 제공학는 API에 의존하기 때문에 악의적인 해커나 악성 프로그램이 윈도우의 DLL파일을 변조하거나 교체한다면 해당 DLL을 사용하는 도구는 신뢰성이 떨어질 것이다.
2. 분석의 반복성이 없음  
Live Response의 정보는 모두 휘발성으로 다음에 다시 수집한다고 해서 데이터가 일치할 것이라 보장할 수 없다.  
따라서 Live Response의 데이터가 합법적인 절차를 통해 수집했다고 해도 증명하지 못할 수 있다.  
객관적인 증명을 위해서는 동일한 환경에서 동일한 수행이나 입력이 되었을 때 동일한 결과가 나와야 하는데 Live Response는 그렇지 않다.  
3. 분석의 다양성이 없음  
조사관은 휘발성 정보를 증거나 참고용으로 제출했으나 상대편에서 반박하면 객관적인 증명을 위해 다른 방법으로 조사하여 동일한 결과가 나온다는 사실을 증거로 제출해야 한다.  
따라서 조사관은 하나의 휘발성 정보를 수집하기 위해 여러 가지 방법을 사용해야 한다.  
하지만 Live Response는 수행 과정에서는 여러 방법을 사용해 정보를 수집할 수 있지만 조사가 끝나면 다시 정보를 수집할 방법이 없다.  

위와 같이 Live Response는 단점을 가지는 반면 메모리 분석은 Live Response에 대해 다음과 같은 장점을 가지고 있다.  

1. 도구의 신뢰성 보장  
메모리 분석 도구에 사용되는 API는 윈도우의 프로세스/메모리 관련 API가 아닌, 파일시스템의 API이기 때문에 API변조와 상관없이 얻어진 결과이기 때문에 신뢰성을 가진다.  
2. 분석의 반복성 보장  
메모리 분석 대상은 변하지 않기 때문에 언제든지 조사를 반복할 수 있으며 Live Response와 달리 동일한 입력값을 통해 동일한 결과값을 가진다.  
3. 분석의 다양성 보장  
메모리 분석 대상은 Live Response와 달리 조사가 끝이 나도 존재하기 때문에 언제든지 다른 조사 방법이나 새로운 조사 방법을 적용하여 조사를 재개할 수 있다.  

Live Response와 메모리의 장점과 단점에 대해 알아보았다.  
한쪽으로 치우치는 분석보다는 서로 상호작용하는 분석의 수행이 중요하다.  

### 메모리 분석에 앞서 알아두어야 할 사항  
1. 메모리 덤프 개요  
메모리 분석에 앞서 해야 할 작업은 메모리 덤프 파일을 시스템으로부터 얻는 것이다.  
메모리 덤프 방법으로는 다음 네 가지가 있다.
    1. 하드웨어를 이용한 방법
    2. 소프트웨어 도구를 이용한 방법
    3. OS 크래시 덤프를 이용한 방법 
    4. 하이버네이션 파일을 이용한 방법  

각 방법은 장점과 단점을 가지고 있어 조사관의 판단에 따라 상황에 맞게 적절하게 사용해야 한다.  
순서대로 차근차근 알아보도록 하자.  

#### 하드웨어를 이용한 메모리 덤프  
하드웨어로 덤프를 수행할 경우 [DMA](https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC)기능을 이용해 OS특성에 상관없이 메모리 덤프 수행이 가능하다.  
또한 응용프로그램을 실행하는 것이 아니기 때문에 시스템 메모리에 어떠한 영향도 미치지 않아 소프트웨어 방식보다 조금 더 정확한 메모리 덤프가 가능하다.  
하지만 덤프 과정의 안전성이 검증되지 않아 시스템에 [크래시](https://ko.wikipedia.org/wiki/%EC%B6%A9%EB%8F%8C_(%EC%BB%B4%ED%93%A8%ED%8C%85))를 일으키는 경우가 있다.  
최신 마더보드의 경우 [MIMO](https://ko.wikipedia.org/wiki/MIMO) 기능을 가지고 있는데 악의적인 사용자가 이 기능으로 메모리 덤프 과정을 방해할 가능성이 있다.  

하드웨어를 이용한 메모리 덤프 방법에는 다음과 같은 종류가 있다.  

1. PCI 장치  
일반적으로 잘 알려진 메모리 덤프 방법으로 Tribble이라는 기기를 사용하며 이는 실험적인 장치이므로 구매가 불가능하다.  
2. Firewire 장치  
윈도우에서 사용이 가능하며 대상 컴퓨터에 무언가를 설치할 필요가 없고, PCI 장치 방법보다 간편하다.

하드웨어를 이용한 방법은 실습할 방법이 없어 설명만으로 공부해야한다.(하려면 장비 구입 요함)  
그러므로 일단은 이런 방법이 있다는 것만 알고 넘어가자.  

#### 소프트웨어를 이용한 메모리 덤프
가장 좋은 장점은 즉석에서 메모리 덤프를 만들 수 있다는 점이다.  
이 때문에 하드웨어를 이용한 방법보다는 소프트웨어를 이용한 방법이 좀 더 많이 쓰이고 있다.  
하지만 OS의 API에 의존하기 때문에 악의적인 사용자가 API를 조작하게 되면 메모리 덤프 결과도 조작되는 셈이 된다.  

이제 소프트웨어를 통한 메모리 덤프 방법에는 어떤 것들이 있는지 알아보자.   

1. DD  
유닉스 도구 중 하나로 GNU License로 배포된다. 간단한 사용법과 좋은 결과물이 장점이다.  
윈도우에서도 적용이 가능한 윈도우 버전도 존재한다.  
DD는 사용자가 접근 가능한 모든 데이터를 바이트 또는 [블록](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_(%EC%BB%B4%ED%93%A8%ED%8C%85)) 단위로 복사하는데 복사하려는 영역을 OS가 인식하지 못하거나, 사용자 권한이 낮아 접근하지 못하는 영역이거나, 지원하는 API가 없는 경우를 제외하고는 모든 시스템 데이터를 덤프할 수 있다.  
DD는 주로 리눅스에서 사용하고, 포맷 이미지는 Raw 데이터 포맷 이미지를 사용한다.  
장점으로는 데이터의 형태를 그대로 덤프한다는 점이고, 단점은 부가정보의 미제공으로 분석에 시간이 오래걸린다는 것이다.  
2. KntDD  
이 도구는 메모리 덤프를 네트워크로 전송하는 기능을 포함하고 있으며 메모리 덤프를 윈도우 크래시 덤프 포맷으로 변환하는 기능도 가지고 있다.  
하지만 이 도구는 보안전문회사나 군, 정부기관에만 제공되어 일반인들은 사용이 불가능하다.  
3. MDD  
메모리 덤프만을 위해 만들어진 도구이다. Windows XP SP2(32bit) 이후 버전에서도 문제없이 수행 가능하지만 업데이트가 되지 않는다.  
그래도 오픈 소스이기 때문에 사용자가 직접 수정하여 사용이 가능하기 때문에 이 부분은 별다른 문제가 되지 않는다.  
4. WIN32(64)DD  
이 도구 또한 MDD처럼 멤리 덤프 전용으로 개발된 도구이다.  
많은 기능을 포함하며, 지원하는 윈도우 버전이 많다.  
기본적으로 로우 포맷을 지원하고 추가로 크래시 포맷과 하이버네이션 포맷을 지원한다.  
네트워크 전송 기능도 가지고 있으며 64bit 시스템 지원과 4GB 이상의 메모리 덤프 또한 지원한다.  
5. Fastdd  
제작자의 말에 따르면 win32dd보다 빠르다고 한다.  
32bit, 64bit를 모두 지원한다.  
6. 기타 상용 도구  
 * FastDump  
CLI 기반의 도구이다.  
 * Pro Discover IR  
메모리 덤프 전용이 아닌 침해사고용으로 개발된 도구이다.  
 * EnCase Enterprise
 * AccessData Enterprise  
기업 환경에서의 네트워크에 있는 컴퓨터의 메모리 덤프를 수집하는데 목적이 있다.  

#### OS Crash dump  
OS가 시스템에 일어난 오류문제의 원인을 찾기 위해 생성되는 메모리 덤프를 말한다.  

__크래시 덤프 생성과정__  
[BSOD](https://en.wikipedia.org/wiki/Blue_Screen_of_Death)이 발생하면 OS는 오류문제를 찾기 위해 메모리를 덤프하여 파일로 저장한다.  
일반적으로 XP는 디스크의 2GB의 여유 저장 공간이 있으면 크래시 덤프 파일(= 전체 메모리 덤프는 메모리 크기 + 300MB의 크기로 생성된다)을 생성하며 Win7의 경우 25GB 이상의 여유 공간이 있어야만 크래시 덤프 파일을 생성한다.  

![HowToMakeCrashDump](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/HowToMakeCrashDump.PNG?raw=true)

Win7의 경우 크래시 덤프 파일을 생성할 때 조건으로 여유 디스크 공간의 크기를 확인하는데 이는 디스크 용량이 충분하지 못한 상황에서 메모리의 덤프를 막아 시스템 리소스 낭비를 줄이자는 의도이다.  
크래시 덤프는 앞서 소개한 메모리 덤프 방법 중 가장 순수한 메모리 덤프 파일을 얻을 수 있다.  
하지만 메모리 덤프 파일을 얻기 위한 방법이 복잡하고 메모리의 전체 덤프를 언제나 얻을 있는 것이 아니다.  
또 OS마다 크래시 덤프 조건이 다르게 설정되어 있어 분석 대상  시스템에 크래시 덤프 파일 생성 설정이 되어 있지 않으면 해당 방법을 사용하기 모호하다.  
크래시 덤프에는 3가지 종류가 있는데 3가지 종류마다 담고 있는 데이터가 다르므로 알아보도록 하자.  

1. 작은 메모리 덤프(Small Memory Dump)  
오류가 발생한 원인을 밝히기 위한 최소한의 정보만 기록한다.  부트 볼륨에 최소한 2MB 이상의 페이지 파일이 있어야 한다.
2. 커널 메모리 덤프(Kernel Memory Dump)  
할당되지 않은 메모리 영역과 사용자 모드로 동작중인 프로그램들에 메모리 영역을 제외한 커널 모드와 [HAL](https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EC%B6%94%EC%83%81%ED%99%94) 메모리 영역만을 기록한다.  
포렌식 관점으로는 사용자 모드 프로그램의 메모리 영역을 기록하지 않아 중요하진 않지만 오류를 수정하기에 적합한 덤프이다.  
3. 전체 메모리 덤프  
이 메모리 덤프를 만들기 위해서는 부트 볼륨에 전체 메모리 크기에 1MB를 더한 만큼의 페이지 파일이 있어야 하며, 32bit 환경에서는 2GB 이상의 메모리는 덤프할 수 없다.  

### [하이버네이션](https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%EB%B2%84%EB%84%A4%EC%9D%B4%EC%85%98)  
시스템에 일정 시간이 지나도 아무런 입력이 없을 때 OS가 모든 메모리 데이터를 하드 드라이브에 기록하고 시스템 구동에 필요한 최소전원공급만을 남겨둔 채 필요없는 전원을 차단하는 기능이다.  
목적은 효율적인 전원 관리로써 우리가 아는 컴퓨터의 [Sleep Mode](https://en.wikipedia.org/wiki/Sleep_mode)와 유사하지만, 이 두 기능에는 다음과 같은 차이가 있다.  

1. 슬립모드  
해당 기능은 메모리의 데이터가 손실되지 않도록 계속 전원을 공급하는 방식이다.  
2. 하이버네이션  
해당 기능은 메모리의 데이터를 하드 드라이브에 기록하고 시스템 구동에 필요하지 않은 전원들은 모두 차단한다.  

두 기능의 차이점은 메모리의 데이터를 유지하는 방식과 전원차단에 있다.  
이로 인해 슬립모드는 다시 시스템을 원상태로 복구하는 시간이 짧지만 하이버네이션은 슬립모드보다 오래 걸린다.  

#### 하이버네이션 장점과 단점  
하이버네이션은 OS의 기능으로 메모리 덤프 파일을 만들기 때문에 추가적인 프로그램이나 장비가 불필요하다.  
또 OS기능을 사용하기 때문에 크래시 덤프와 견줄 정도의 순수한 메모리 덤프 파일을 얻을 수 있다.  
하지만 하이버네이션 파일이 존재한다 하더라도 침해사고 발생 전에 생긴 파일일 수도 있다.  
또한 메모리를 전체적으로 덤프하는 것도 아니며, OS뿐만이 아닌 마더보드도 이 기능을 지원해야만 한다.  
제일 중요한 점은 일반 PC의 경우 이 기능이 기본적으로 비활성화되어 있다는 것이다.  

#### 하이버네이션 수행 조건  
하이버네이션의 기능을 이용한 메모리 덤프 파일 결과물을 얻기 위해 다음과 같은 조건이 있어야 한다.  

1. CMOS와 OS설정에서 하이버네이션 설정이 되어 있어야 한다. 
2. 시스템에 일정 시간동안 입력이 없어야 하며, 서비스나 프로세스에 의해서 입력이 있어서도 안된다.  

하이버네이션은 XP기준으로 [제어판] -> [전원옵션] -> [최대 절전 모드 탭]에서 확인이 가능하다.  
~여기서 하이버네이션이 최대 절전 모드라는 것을 처음 알았다.~  
아무튼 '최대 절전 모드 사용'에 체크가 되어 있어야 하이버네이션 기능이 활성화된다.  
하이버네이션으로 생성되는 파일은 hiberfil.sys이며, pagefile.sys와 같은 위치에 저장되어 있다.  
참고로 하이버네이션 기능을 사용하며 메모리 분석을 하면 좋겠지만, 필요성을 느끼지 못한다면 굳이 할 필요는 없다.  

### 가상 메모리 구조  

#### 가상 메모리 정의  
가상 메모리란 물리적인 실체를 가지고 있지 않은 메모리를 말하며, OS가 만들어낸 논리적인 형태의 메모리를 뜻한다.  
가상 메모리에 저장된 데이터라고 가상으로 저장할 수는 없으므로 가상 메모리의 데이터는 물리메모리나 하드 드라이브에 저장된다.  
가상 메모리는 [VAS](https://en.wikipedia.org/wiki/Virtual_address_space)라는 것을 OS로부터 할당받는다.  

32bit 시스템의 경우 4GB 크기의 가상 메모리 영역을 할당받으며, 64bit 시스템의 경우 이론적으로 17EB(엑사바이트)의 가상 메모리 영역을 할당받지만 크기가 너무 크고 비효율적이어서 8TB정도로 제한을 하고 있다.  
가상 메모리의 크기는 위의 설명에서 보았듯이 시스템의 bit(중앙 처리 장치의 버스가 자료를 비트 단위)에 따라 정해져 있으며 프로세스의 크기에 따라 변하지 않고 무조건적으로 정해진 크기가 할당된다.  

또한 프로세스는 자신에게 할당된 가상메모리의 영역을 자신의 것으로만 생각하고 단편화되지 않은 연속적인 주소의 공간으로 인식한다.  
그렇기에 매번 고정된 크기의 가상 메모리를 할당받아 프로세스는 시스템마다 다른 메모리 크기의 한계를 느끼지 않고 실행될 수 있는 것이다.
![StructureofVirtualMemory](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/StructureofMemory.PNG?raw=true)  

가상 메모리를 간단하게 도해하면 [그림 2.62]와 같지만, 좀 더 세부적으로 그린다면 [그림 2.63]과 같다.  
[그림 2.63]을 보면 가상 메모리의 커널 영역은 여러 가지의 것들이 들어가 있는 것을 볼 수 있는데, 커널 영역은 그림처럼 순차적으로 저장되어 있지 않고 여기저기 흩어져 있다.  
이해하기 쉽도록 그림을 다음과 같이 그렸다는 것을 참고로 알아두기 바란다.  

메모리 덤프를 하면 사용자영역에 있는 데이터들은 불완전한 형태로 덤프되는 경우가 있고 커널 영역은 온전한 형태로 덤프가 되는 경우가 있는데 이러한 경우는 가상 메모리의 사용자 영역에서 데이터가 물리적 메모리와 페이지 파일을 오고 가기 때문이다.  
프로세스가 사용하는 데이터가 오랫동안 사용되지 않을 경우 페이지 파일에 저장해두고 필요한 경우 다시 물리적 메모리에 적재해 사용하는 방식 때문에 불완전하게 덤프가 되는 것이다.  

커널 영역의 경우 시스템에 필요한 데이터들이고 자주 사용되는 것들이기 때문에 페이지 파일에 저장하지 않고 물리메모리에 저장되기 때문에 온전하게 덤프가 되는 것이다.  
가상 메모리와 물리적 메모리의 주소는 맵핑이 되어 있는데 가상 메모리의 어떤 데이터의 주소가 다른 프로세스의 가상 메모리의 어떤 데이터 주소와 같다고 하더라도 물리적 메모리에서의 주소는 다르기 때문에 서로 충돌이 일어나거나 데이터를 덮어씌우지 않는다.  
[그림 2.64]는 두 개의 서로 다른 프로세스가 똑같은 가상메모리 주소에 똑같은 데이터를 저장하였을 때 물리적 메모리에는 어떻게 저장되는가를 보여주는 그림이다.
![HowPhysicalMemorySavesTheData](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/HowPhysicalMemorySaves.PNG?raw=true)  
[그림 2.64]를 이해했다면 이제 가상 메모리와 물리적 메모리 간의 주소가 어떻게 변환되는지는 알아야 한다.  
변환 방법에 대해서 알아보도록 하자.
