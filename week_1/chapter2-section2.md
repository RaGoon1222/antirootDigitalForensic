# Memory 분석
>*주로 윈도우에 관한 이야기만 다룬다.*  
포렌식에서 빼놓을 수 없는 메모리 분석에 대한 이야기이다.  
메모리에는 프로세스가 사용한 데이터와 프로세스 자체, 웹 브라우저를 통해 전송된 정보, 복호화된 데이터 등이 기록되어 있다.  
메모리 분석에 대한 연구는 (이 책 기준)현재진행형이므로 파일시스템 분석이나 레지스트리 분석과 비교할 때는 아직 부족하지만 시스템의 많은 정보를 알아낼 수 있으므로 메모리에 대해 반드시 알고 정보 활용 능력을 길러야 한다.

### 메모리 분석의 관심과 장점, 단점
1. 하드디스크에서 실행되지 않고 메모리상에서 바로 실행되는 악성코드의 존재  
이런 경우, 하드디스크를 이미지 파일로 만들어 분석한다 하더라도 악성 파일의 실행 원본 파일이나 흔적을 하드디스크에서 찾을 수 없으므로 메모리 분석이 필요하다.
2. 사용자 응용 프로그램의 프라이버시 보호 기능 강화  
요즘은 암호화나 개인정보보호 프로그램이 일반화되어 범용되어진다.  
이러한 프로그램들은 일반 사용자의 개인 파일들을 보호하지만, 시스템에 침투한 악성코드 또한 보호하는 경우가 발생한다.   
개인정보보호 프로그램이 악성코드 판별 기능이 없기 때문이다.   
이러한 상황에서 악성코드를 분석하려면 메모리 영역을 분석해야한다.  
실행 파일들은 메모리 영역에서는 복호화되어 실행되기 때문이다.  
3. [안티 포렌식(Anti Forensic)](https://en.wikipedia.org/wiki/Anti-computer_forensics)기술의 확산으로 하드 드라이브에 존재하고 있는 데이터의 무결성 불완전  
안티 포렌식 기술은 [루트킷](https://ko.wikipedia.org/wiki/%EB%A3%A8%ED%8A%B8%ED%82%B7)의 경우 나쁘다고 할 수 있지만 데이터 완전 삭제 기술 같은 경우, 일반 사용자들에게는 개인정보파일들을 유출되지 못하도록 하는 기술이기 때문에 좋다고 할 수도 있다.  
아무튼 루트킷이나 데이터 완전 삭제 기술의 경우 무결성을 저해하는 행위이기 때문에 하드디스크가 아닐 경우 메모리에서밖에 복구하지 못한다.  
메모리의 데이터도 완전하지는 않지만 그래도 수집하여 분석하는 것이 도움되기 때문에 메모리 영역을 분석해 데이터를 추출해야 한다.  

위와 같은 이유로 포렌식 관점의 메모리 분석 분야가 관심받기 시작했지만 (이 책 기준)아직까지는 발전 단계가 낮다.  
메모리 분석을 위한 선행 지식이 방대하고 구조는 운영체제마다 다른데다 세부적으로 패치에 따라 달라지기 때문이다. 
 
Live Response에 메모리 분석 과정이 포함될 수 있는데 이는 메모리 분석을 통해 얻는 정보가 대부분 Live Response 정보와 일치하기 때문이다.  
그렇기에 Live Response 과정에 메모리 분석을 넣는 것은 조사관 판단에 달려 있다.  
얻어지는 정보가 비슷하거나 일치한다고 해서 서로 대체하거는 것이 불가능하다.  
Live Response는 메모리 분석과 비교하였을 때 다음과 같은 단점을 지니고 있다.  

1. 도구의 신뢰성 저하  
Live Response 도구들은 대부분 윈도우에서 기본적으로 제공학는 API에 의존하기 때문에 악의적인 해커나 악성 프로그램이 윈도우의 DLL파일을 변조하거나 교체한다면 해당 DLL을 사용하는 도구는 신뢰성이 떨어질 것이다.
2. 분석의 반복성이 없음  
Live Response의 정보는 모두 휘발성으로 다음에 다시 수집한다고 해서 데이터가 일치할 것이라 보장할 수 없다.  
따라서 Live Response의 데이터가 합법적인 절차를 통해 수집했다고 해도 증명하지 못할 수 있다.  
객관적인 증명을 위해서는 동일한 환경에서 동일한 수행이나 입력이 되었을 때 동일한 결과가 나와야 하는데 Live Response는 그렇지 않다.  
3. 분석의 다양성이 없음  
조사관은 휘발성 정보를 증거나 참고용으로 제출했으나 상대편에서 반박하면 객관적인 증명을 위해 다른 방법으로 조사하여 동일한 결과가 나온다는 사실을 증거로 제출해야 한다.  
따라서 조사관은 하나의 휘발성 정보를 수집하기 위해 여러 가지 방법을 사용해야 한다.  
하지만 Live Response는 수행 과정에서는 여러 방법을 사용해 정보를 수집할 수 있지만 조사가 끝나면 다시 정보를 수집할 방법이 없다.  

위와 같이 Live Response는 단점을 가지는 반면 메모리 분석은 Live Response에 대해 다음과 같은 장점을 가지고 있다.  

1. 도구의 신뢰성 보장  
메모리 분석 도구에 사용되는 API는 윈도우의 프로세스/메모리 관련 API가 아닌, 파일시스템의 API이기 때문에 API변조와 상관없이 얻어진 결과이기 때문에 신뢰성을 가진다.  
2. 분석의 반복성 보장  
메모리 분석 대상은 변하지 않기 때문에 언제든지 조사를 반복할 수 있으며 Live Response와 달리 동일한 입력값을 통해 동일한 결과값을 가진다.  
3. 분석의 다양성 보장  
메모리 분석 대상은 Live Response와 달리 조사가 끝이 나도 존재하기 때문에 언제든지 다른 조사 방법이나 새로운 조사 방법을 적용하여 조사를 재개할 수 있다.  

Live Response와 메모리의 장점과 단점에 대해 알아보았다.  
한쪽으로 치우치는 분석보다는 서로 상호작용하는 분석의 수행이 중요하다.  

### 메모리 분석에 앞서 알아두어야 할 사항  
1. 메모리 덤프 개요  
메모리 분석에 앞서 해야 할 작업은 메모리 덤프 파일을 시스템으로부터 얻는 것이다.  
메모리 덤프 방법으로는 다음 네 가지가 있다.
    1. 하드웨어를 이용한 방법
    2. 소프트웨어 도구를 이용한 방법
    3. OS 크래시 덤프를 이용한 방법 
    4. 하이버네이션 파일을 이용한 방법  

각 방법은 장점과 단점을 가지고 있어 조사관의 판단에 따라 상황에 맞게 적절하게 사용해야 한다.  
순서대로 차근차근 알아보도록 하자.  

#### 하드웨어를 이용한 메모리 덤프  
하드웨어로 덤프를 수행할 경우 [DMA](https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%A0%91%EA%B7%BC)기능을 이용해 OS특성에 상관없이 메모리 덤프 수행이 가능하다.  
또한 응용프로그램을 실행하는 것이 아니기 때문에 시스템 메모리에 어떠한 영향도 미치지 않아 소프트웨어 방식보다 조금 더 정확한 메모리 덤프가 가능하다.  
하지만 덤프 과정의 안전성이 검증되지 않아 시스템에 [크래시](https://ko.wikipedia.org/wiki/%EC%B6%A9%EB%8F%8C_(%EC%BB%B4%ED%93%A8%ED%8C%85))를 일으키는 경우가 있다.  
최신 마더보드의 경우 [MIMO](https://ko.wikipedia.org/wiki/MIMO) 기능을 가지고 있는데 악의적인 사용자가 이 기능으로 메모리 덤프 과정을 방해할 가능성이 있다.  

하드웨어를 이용한 메모리 덤프 방법에는 다음과 같은 종류가 있다.  

1. PCI 장치  
일반적으로 잘 알려진 메모리 덤프 방법으로 Tribble이라는 기기를 사용하며 이는 실험적인 장치이므로 구매가 불가능하다.  
2. Firewire 장치  
윈도우에서 사용이 가능하며 대상 컴퓨터에 무언가를 설치할 필요가 없고, PCI 장치 방법보다 간편하다.

하드웨어를 이용한 방법은 실습할 방법이 없어 설명만으로 공부해야한다.(하려면 장비 구입 요함)  
그러므로 일단은 이런 방법이 있다는 것만 알고 넘어가자.  

#### 소프트웨어를 이용한 메모리 덤프
가장 좋은 장점은 즉석에서 메모리 덤프를 만들 수 있다는 점이다.  
이 때문에 하드웨어를 이용한 방법보다는 소프트웨어를 이용한 방법이 좀 더 많이 쓰이고 있다.  
하지만 OS의 API에 의존하기 때문에 악의적인 사용자가 API를 조작하게 되면 메모리 덤프 결과도 조작되는 셈이 된다.  

이제 소프트웨어를 통한 메모리 덤프 방법에는 어떤 것들이 있는지 알아보자.   

1. DD  
유닉스 도구 중 하나로 GNU License로 배포된다. 간단한 사용법과 좋은 결과물이 장점이다.  
윈도우에서도 적용이 가능한 윈도우 버전도 존재한다.  
DD는 사용자가 접근 가능한 모든 데이터를 바이트 또는 [블록](https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_(%EC%BB%B4%ED%93%A8%ED%8C%85)) 단위로 복사하는데 복사하려는 영역을 OS가 인식하지 못하거나, 사용자 권한이 낮아 접근하지 못하는 영역이거나, 지원하는 API가 없는 경우를 제외하고는 모든 시스템 데이터를 덤프할 수 있다.  
DD는 주로 리눅스에서 사용하고, 포맷 이미지는 Raw 데이터 포맷 이미지를 사용한다.  
장점으로는 데이터의 형태를 그대로 덤프한다는 점이고, 단점은 부가정보의 미제공으로 분석에 시간이 오래걸린다는 것이다.  
2. KntDD  
이 도구는 메모리 덤프를 네트워크로 전송하는 기능을 포함하고 있으며 메모리 덤프를 윈도우 크래시 덤프 포맷으로 변환하는 기능도 가지고 있다.  
하지만 이 도구는 보안전문회사나 군, 정부기관에만 제공되어 일반인들은 사용이 불가능하다.  
3. MDD  
메모리 덤프만을 위해 만들어진 도구이다. Windows XP SP2(32bit) 이후 버전에서도 문제없이 수행 가능하지만 업데이트가 되지 않는다.  
그래도 오픈 소스이기 때문에 사용자가 직접 수정하여 사용이 가능하기 때문에 이 부분은 별다른 문제가 되지 않는다.  
4. WIN32(64)DD  
이 도구 또한 MDD처럼 멤리 덤프 전용으로 개발된 도구이다.  
많은 기능을 포함하며, 지원하는 윈도우 버전이 많다.  
기본적으로 로우 포맷을 지원하고 추가로 크래시 포맷과 하이버네이션 포맷을 지원한다.  
네트워크 전송 기능도 가지고 있으며 64bit 시스템 지원과 4GB 이상의 메모리 덤프 또한 지원한다.  
5. Fastdd  
제작자의 말에 따르면 win32dd보다 빠르다고 한다.  
32bit, 64bit를 모두 지원한다.  
6. 기타 상용 도구  
 * FastDump  
CLI 기반의 도구이다.  
 * Pro Discover IR  
메모리 덤프 전용이 아닌 침해사고용으로 개발된 도구이다.  
 * EnCase Enterprise
 * AccessData Enterprise  
기업 환경에서의 네트워크에 있는 컴퓨터의 메모리 덤프를 수집하는데 목적이 있다.  

#### OS Crash dump  
OS가 시스템에 일어난 오류문제의 원인을 찾기 위해 생성되는 메모리 덤프를 말한다.  

__크래시 덤프 생성과정__  
[BSOD](https://en.wikipedia.org/wiki/Blue_Screen_of_Death)이 발생하면 OS는 오류문제를 찾기 위해 메모리를 덤프하여 파일로 저장한다.  
일반적으로 XP는 디스크의 2GB의 여유 저장 공간이 있으면 크래시 덤프 파일(= 전체 메모리 덤프는 메모리 크기 + 300MB의 크기로 생성된다)을 생성하며 Win7의 경우 25GB 이상의 여유 공간이 있어야만 크래시 덤프 파일을 생성한다.  

![HowToMakeCrashDump](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/HowToMakeCrashDump.PNG?raw=true)

Win7의 경우 크래시 덤프 파일을 생성할 때 조건으로 여유 디스크 공간의 크기를 확인하는데 이는 디스크 용량이 충분하지 못한 상황에서 메모리의 덤프를 막아 시스템 리소스 낭비를 줄이자는 의도이다.  
크래시 덤프는 앞서 소개한 메모리 덤프 방법 중 가장 순수한 메모리 덤프 파일을 얻을 수 있다.  
하지만 메모리 덤프 파일을 얻기 위한 방법이 복잡하고 메모리의 전체 덤프를 언제나 얻을 있는 것이 아니다.  
또 OS마다 크래시 덤프 조건이 다르게 설정되어 있어 분석 대상  시스템에 크래시 덤프 파일 생성 설정이 되어 있지 않으면 해당 방법을 사용하기 모호하다.  
크래시 덤프에는 3가지 종류가 있는데 3가지 종류마다 담고 있는 데이터가 다르므로 알아보도록 하자.  

1. 작은 메모리 덤프(Small Memory Dump)  
오류가 발생한 원인을 밝히기 위한 최소한의 정보만 기록한다.  부트 볼륨에 최소한 2MB 이상의 페이지 파일이 있어야 한다.
2. 커널 메모리 덤프(Kernel Memory Dump)  
할당되지 않은 메모리 영역과 사용자 모드로 동작중인 프로그램들에 메모리 영역을 제외한 커널 모드와 [HAL](https://ko.wikipedia.org/wiki/%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4_%EC%B6%94%EC%83%81%ED%99%94) 메모리 영역만을 기록한다.  
포렌식 관점으로는 사용자 모드 프로그램의 메모리 영역을 기록하지 않아 중요하진 않지만 오류를 수정하기에 적합한 덤프이다.  
3. 전체 메모리 덤프  
이 메모리 덤프를 만들기 위해서는 부트 볼륨에 전체 메모리 크기에 1MB를 더한 만큼의 페이지 파일이 있어야 하며, 32bit 환경에서는 2GB 이상의 메모리는 덤프할 수 없다.  

### [하이버네이션](https://ko.wikipedia.org/wiki/%ED%95%98%EC%9D%B4%EB%B2%84%EB%84%A4%EC%9D%B4%EC%85%98)  
시스템에 일정 시간이 지나도 아무런 입력이 없을 때 OS가 모든 메모리 데이터를 하드 드라이브에 기록하고 시스템 구동에 필요한 최소전원공급만을 남겨둔 채 필요없는 전원을 차단하는 기능이다.  
목적은 효율적인 전원 관리로써 우리가 아는 컴퓨터의 [Sleep Mode](https://en.wikipedia.org/wiki/Sleep_mode)와 유사하지만, 이 두 기능에는 다음과 같은 차이가 있다.  

1. 슬립모드  
해당 기능은 메모리의 데이터가 손실되지 않도록 계속 전원을 공급하는 방식이다.  
2. 하이버네이션  
해당 기능은 메모리의 데이터를 하드 드라이브에 기록하고 시스템 구동에 필요하지 않은 전원들은 모두 차단한다.  

두 기능의 차이점은 메모리의 데이터를 유지하는 방식과 전원차단에 있다.  
이로 인해 슬립모드는 다시 시스템을 원상태로 복구하는 시간이 짧지만 하이버네이션은 슬립모드보다 오래 걸린다.  

#### 하이버네이션 장점과 단점  
하이버네이션은 OS의 기능으로 메모리 덤프 파일을 만들기 때문에 추가적인 프로그램이나 장비가 불필요하다.  
또 OS기능을 사용하기 때문에 크래시 덤프와 견줄 정도의 순수한 메모리 덤프 파일을 얻을 수 있다.  
하지만 하이버네이션 파일이 존재한다 하더라도 침해사고 발생 전에 생긴 파일일 수도 있다.  
또한 메모리를 전체적으로 덤프하는 것도 아니며, OS뿐만이 아닌 마더보드도 이 기능을 지원해야만 한다.  
제일 중요한 점은 일반 PC의 경우 이 기능이 기본적으로 비활성화되어 있다는 것이다.  

#### 하이버네이션 수행 조건  
하이버네이션의 기능을 이용한 메모리 덤프 파일 결과물을 얻기 위해 다음과 같은 조건이 있어야 한다.  

1. CMOS와 OS설정에서 하이버네이션 설정이 되어 있어야 한다. 
2. 시스템에 일정 시간동안 입력이 없어야 하며, 서비스나 프로세스에 의해서 입력이 있어서도 안된다.  

하이버네이션은 XP기준으로 [제어판] -> [전원옵션] -> [최대 절전 모드 탭]에서 확인이 가능하다.  
~여기서 하이버네이션이 최대 절전 모드라는 것을 처음 알았다.~  
아무튼 '최대 절전 모드 사용'에 체크가 되어 있어야 하이버네이션 기능이 활성화된다.  
하이버네이션으로 생성되는 파일은 hiberfil.sys이며, pagefile.sys와 같은 위치에 저장되어 있다.  
참고로 하이버네이션 기능을 사용하며 메모리 분석을 하면 좋겠지만, 필요성을 느끼지 못한다면 굳이 할 필요는 없다.  

### 가상 메모리 구조  

#### 가상 메모리 정의  
가상 메모리란 물리적인 실체를 가지고 있지 않은 메모리를 말하며, OS가 만들어낸 논리적인 형태의 메모리를 뜻한다.  
가상 메모리에 저장된 데이터라고 가상으로 저장할 수는 없으므로 가상 메모리의 데이터는 물리메모리나 하드 드라이브에 저장된다.  
가상 메모리는 [VAS](https://en.wikipedia.org/wiki/Virtual_address_space)라는 것을 OS로부터 할당받는다.  

32bit 시스템의 경우 4GB 크기의 가상 메모리 영역을 할당받으며, 64bit 시스템의 경우 이론적으로 17EB(엑사바이트)의 가상 메모리 영역을 할당받지만 크기가 너무 크고 비효율적이어서 8TB정도로 제한을 하고 있다.  
가상 메모리의 크기는 위의 설명에서 보았듯이 시스템의 bit(중앙 처리 장치의 버스가 자료를 비트 단위)에 따라 정해져 있으며 프로세스의 크기에 따라 변하지 않고 무조건적으로 정해진 크기가 할당된다.  

또한 프로세스는 자신에게 할당된 가상메모리의 영역을 자신의 것으로만 생각하고 단편화되지 않은 연속적인 주소의 공간으로 인식한다.  
그렇기에 매번 고정된 크기의 가상 메모리를 할당받아 프로세스는 시스템마다 다른 메모리 크기의 한계를 느끼지 않고 실행될 수 있는 것이다.
![StructureofVirtualMemory](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/StructureofMemory.PNG?raw=true)  

가상 메모리를 간단하게 도해하면 [그림 2.62]와 같지만, 좀 더 세부적으로 그린다면 [그림 2.63]과 같다.  
[그림 2.63]을 보면 가상 메모리의 커널 영역은 여러 가지의 것들이 들어가 있는 것을 볼 수 있는데, 커널 영역은 그림처럼 순차적으로 저장되어 있지 않고 여기저기 흩어져 있다.  
이해하기 쉽도록 그림을 다음과 같이 그렸다는 것을 참고로 알아두기 바란다.  

메모리 덤프를 하면 사용자영역에 있는 데이터들은 불완전한 형태로 덤프되는 경우가 있고 커널 영역은 온전한 형태로 덤프가 되는 경우가 있는데 이러한 경우는 가상 메모리의 사용자 영역에서 데이터가 물리적 메모리와 페이지 파일을 오고 가기 때문이다.  
프로세스가 사용하는 데이터가 오랫동안 사용되지 않을 경우 페이지 파일에 저장해두고 필요한 경우 다시 물리적 메모리에 적재해 사용하는 방식 때문에 불완전하게 덤프가 되는 것이다.  

커널 영역의 경우 시스템에 필요한 데이터들이고 자주 사용되는 것들이기 때문에 페이지 파일에 저장하지 않고 물리메모리에 저장되기 때문에 온전하게 덤프가 되는 것이다.  
가상 메모리와 물리적 메모리의 주소는 맵핑이 되어 있는데 가상 메모리의 어떤 데이터의 주소가 다른 프로세스의 가상 메모리의 어떤 데이터 주소와 같다고 하더라도 물리적 메모리에서의 주소는 다르기 때문에 서로 충돌이 일어나거나 데이터를 덮어씌우지 않는다.  
[그림 2.64]는 두 개의 서로 다른 프로세스가 똑같은 가상메모리 주소에 똑같은 데이터를 저장하였을 때 물리적 메모리에는 어떻게 저장되는가를 보여주는 그림이다.
![HowPhysicalMemorySavesTheData](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/HowPhysicalMemorySaves.PNG?raw=true)  
[그림 2.64]를 이해했다면 이제 가상 메모리와 물리적 메모리 간의 주소가 어떻게 변환되는지는 알아야 한다.  
변환 방법에 대해서 알아보도록 하자.
#### 가상 메모리와 물리적 메모리 사이의 주소 변환
가상 메모리의 주소는 32bit 시스템에서는 32bit 길이를 갖는다.  
가상 주소가 물리주소로 변환될 때에는 2개의 [테이블](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%9D%B4%EB%B8%94_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4))과 한 개의 [오프셋](https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%84%EC%85%8B_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99))을 거쳐 변환되는데 이러한 변환 과정을 거치는 이유는 4GB 가상 메모리와 페이지 프레임 단위로 구성되어 있는 실제 메모리 사이의 맵핑 정보를 하나의 표로 만들게 되면 4MB 정도가 되는 표가 만들어진다.  
프로세스마다 이러한 표를 만들어 메모리에 적재하면 메모리 낭비이고, 만들지 않으면 맵핑 속도가 크게 저하된다는 문제점이 생긴다.  

이러한 이유로 위도우는 가상 메모리와 물리적 메모리 사이의 맵핑을 2개의 테이블로 나누고, 그 중 첫번째 테이블(페이지 디렉토리 테이블)만 메모리에 보관하고 나머지 하나의 테이블을 필요할 때만 메모리에 적재한다.  
메모리는 페이지(page)라는 단위로 불리는 일정 크기의 단위를 사용하여 물리적 메모리를 관리하는데 가상 주소와 물리적 주소의 맵핑 또한 이 페이지를 기준으로 이루어진다.  

#### 가상주소를 이용해 물리주소 찾기  
그러면 OS는 우리가 흔히 보는 가상 주소를 이용해 어떻게 물리 주소를 찾을까?  
각각의 페이지는 첫 번째 페이지부터 0번호가 매겨지며, 이 번호를 페이지 프레임 넘버(Page Frame Number)라고 한다.  
가상 주소의 구조는 다음과 같다.  

>가상 주소 = 페이지 디렉토리 인덱스(10bit) + 페이지 테이블 인덱스(10bit) + 바이트주소 인덱스(12bit) = 32bit

이와 같은 정보를 이용하여 OS는 가상 주소를 토대로 물리적 주소를 찾을 수 있다.  
방법은 다음과 같다.  

1. [페이지 디렉토리의 엔트리](https://0x200.tistory.com/entry/8-%ED%8E%98%EC%9D%B4%EC%A7%95-2-%E2%80%93-%ED%8E%98%EC%9D%B4%EC%A7%95)에 저장된 페이지 테이블 주소를 읽고 해당 주소에 있는 페이지 테이블로 이동한다.  
그 후 가상 주소에 존재하는 페이지 테이블 인덱스 값으로 해당 페이지 테이블에서 해당하는 인덱스를 찾아 그 값을 읽는다.  
페이지 테이블 엔트리에는 물리적 주소의 페이지 프레임 주소가 들어있다.(페이지 프레임으로 이동)  
2. 가상 주소의 페이지 디렉토리 인덱스 값에서 현재 프로세스의 페이지 디렉토리의 엔트리를 찾고 그 값을 읽는다.  
페이지 디렉토리 엔트리에는 페이지 테이블의 주소 정보가 들어 있다.(페이지 테이블로 이동)  
3. 페이지 디렉토리의 엔트리에 저장된 페이지 테이블 인덱스 값으로 페이지 테이블 엔트리를 찾아 그 값을 읽는다.  
페이지 테이블 엔트리에는 물리적 주소의 페이지 프레임 주소가 들어있다.(페이지 프레임으로 이동)
4. 가상 주소의 마지막 부분에 있는 바이트주소 인덱스를 이용해서 실제 찾고자 하는 물리적 메모리의 주소로 이동하고 필요한 만큼 데이터를 읽는다.  

위의 설명을 그림으로 표현하면 [그림 2.65]와 같다.  

![RoadMapUsingVirtualAddress](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/RoadMapUsingVirtualAddress.PNG?raw=true)
프로세스마다 페이지 디렉토리를 가지고 있으며 이것의 물리적 주소는 [KPROCESS](http://blog.naver.com/PostView.nhn?blogId=s2kiess&logNo=30180931485) 구조체 안에 저장되어 있다가 [Context Switching](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)이 발생하면 [CR3 레지스터](https://en.wikipedia.org/wiki/Control_register#CR3)로 복사된다.  
실제 프로세스 오브젝트는 가상 메모리에서 보이는 것과 달리 물리적 메모리에 단편화 되어 저장되는데, 흩어져 있는 프로세스 데이터를 가상 주소를 근거로 찾으려면 반드시 페이지 디렉토리의 물리적 주소가 필요하다. KPROCESS 구조 안에 페이지 디렉토리의 물리적 주소가 아닌 가상 주소가 저장되어 있다면 가상 주소와 물리적 주소의 맵핑은 불가능하다.  

이것을 처음 이해하기는 조금 힘이 들 것이다.  
또하 [그림 2.65]의 과정을 이해하는 것도 처음에는 어렵겠지만 순서를 읽고 그림의 화살표를 따라가다 보면 이해에 조금 도움이 될 것이다.  

### [프로세스](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)  
메모리 분석에서 제일 중요한 것은 프로세스를 찾는 것이다.  
특히 루트킷에 의해 숨겨진 프로세스를 찾는 것은 안티루트킷 도구들과 메모리 분석으로 할 수 있는데, 안티루트킷 도구를 사용하면 조사환경에 어떤 영향을 주는지 몰라 메모리 분석보다 좋지 못한 방법이라고 할 수 있다.(무조건적으로는 아니다)

메모리에서 프로세스를 찾기 전, 프로세스의 정보 저장과 관리방법에 대해 공부를 해야 한다.  
그러므로 이번에는 윈도우에서 프로세스를 어떻게 관리하고 다루는지 알아 볼 것이다.  
또한 프로세스를 숨기는 방법 중 가장 대표적인 [DKOM](https://ko.wikipedia.org/wiki/%EC%A7%81%EC%A0%91_%EC%BB%A4%EB%84%90_%EA%B0%9D%EC%B2%B4_%EC%A1%B0%EC%9E%91)의 원리도 공부 해 볼 것이다.  

윈도우에선 [EPROCESS](http://blog.naver.com/PostView.nhn?blogId=s2kiess&logNo=30180931485)라는 구조체에 프로세스의 모든 정보가 들어가 있다.  
[그림 2.66]은 [windbg](https://docs.microsoft.com/ko-kr/windows-hardware/drivers/debugger/getting-started-with-windbg--kernel-mode-) 커널 디버깅 모드로 본 XP SP2의 EPROCESS 구조체 정보이다.  

![EPROCESS](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/EPROCESS.PNG?raw=true)

[그림 2.66]을 제외하고도 많은 정보들이 더 나왔지만 글이 불필요하게 길어지는 것을 방지하고자 [그림 2.66]만 첨부하였다.  
직관적인 이름의 항목들이 많이 보이고, 프로그래밍을 해본 사람이라면 이해할 데이터 타입들도 눈에 띈다.  
하지만 포렌식 관점에서 중요한 부분은 몇 개 되지 않는다.  
왜냐하면 포렌식 관점에서는 다음과 같은 필드들을 주로 보기 때문이다.  

1. [PCB(Process Control Block)](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%A0%9C%EC%96%B4_%EB%B8%94%EB%A1%9D)  
DISPATCHER_HEADER, 디렉토리 테이블 주소, KTHREAD 목록, 우선순위, 커널/유저 CPU 시간 등에 대한 정보를 가진다.  
2. CreateTime  
프로세스가 시작된 시간 정보이며, 64bit 윈도우 시간 형식을 지닌다.  
3. ExitTime  
프로세스가 종료된 시간 정보이며, 또한 64bit 윈도우 시간 형식을 지닌다.  
4. UniqueProcessID  
프로세스의 ID값이다.  
5. ActiveProcessLinks  
ActiveProcess List를 구성하는 이중 연결리스트이다. 
6. ObjectTable  
오브젝트 핸들 테이블의 위치를 가리키는 포인터 값이다.  
7. WorkingSet(어떠한 특수 프로세스 전용으로 할당된 물리적 메모리 페이지의 그룹) Page  
프로세스의 WorkingSetPage이다.  
8. PEB(Process Environment Block)  
프로세스 실행에 필요한 정보를 담고 있으며, BaseAddress, Module List, Heap/Stack 정보가 들어있다.  

만약 메모리 덤프파일에서 프로세스를 찾는다면 PCB와 ActiveProcessLinks 항목을 주로 이용할 것이며, 프로세스 정보를 찾는다면 나머지 필드들과 PEB 항목을 주로 이용할 것이다.  
EPROCESS의 PCB 항목 데이터 타입을 보면 KPROCESS는 EPROCESS의 하부 구조체로써 프로세스의 스케줄링 관련 정보를 저장하고 있다.  
KPROCESS의 하부 구조체 중 DISPATCHER_HEADER라는 하부 구조체는 프로세스들 사이의 동기화에 필요한 구조체로써 메모리 덤프에서 오브젝트를 찾을 때 중요한 역할을 한다.  

커널 영역에 있는 또 다른 구조체인 ETHREAD, KTHREAD는 위의 구조체와 구조는 같으나 다루는 대상이 스레드라는 점에서 차이가 있다.  
[그림 2.67]은 KPROCESS 구조체의 정보를 windbg 커널 디버깅 모드로 확인한 이미지이다.  

![KPROCESS](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/KPROCESS.PNG?raw=true)

#### PEB  
PEB는 EPROCESS의 하부 구조체 중 하나로써, 프로세스의 환경설정 값을 가진다.  
하지만 값을 직접 가지지 않고 사용자 영역의 PEB에 대한 포인터 값을 가진다.  
커널 영역에 속하는 PEB를 사용자 영역에 하나 더 두고 그것의 포인터 값을 가지는지는 아래와 같이 설명할 수 있다.  
PEB에 저장되는 데이터는 사용자 모드로 접근하는 이미지 로더, 힙 매니저, 윈도우 시스템 DLL 파일이 필요로 하는 정보이기 때문이다.  
그렇기에 커널 영역에 있으면 접근이 어려우므로 사용자 영역에 저장하는 것이다.  
[그림 2.68]은 PEB 구조체의 정보이다.
![XPSP2PEB](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/PEB.PNG?raw=true)

#### ActiveProcessLink  
ActiveProcessLink는 원형 이중 링크드 리스트로 이루어져 있으며, 이 항목을 통해 프로세스의 목록을 얻을 수도 있다.  
이중 링크드 리스트는 간단히 표현하면 [그림 2.69]와 같이 나타낼 수 있다.  
![이중링크드리스트](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/DoubleLinkedList.PNG?raw=true)  
원형 이중 링크드 리스트는 이중 링크드 리스트에 PsActiveProcessLink라는 커널 전역변수를 추가해 순환 구조를 만들어 준 것이다.  
![원형이중링크드리스트](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/DoublyCircularLinkedList.PNG?raw=true)  
그림을 한눈에 봐서는 이해가 안 될 수 있다.  
그러므로 화살표를 유의하며 보길 바란다.  
PsactiveProcessLink 변수에 대해 좀 더 설명하자면, 이 변수는 ActiveProcessLink(작업관리자의 System 프로세스는 윈도우 커널을 의미하며, 언제나 ActiveProcessLink의 첫번째 프로세스이다.)와 같은 구조로 되어 있고, 이 변수에 접근하기 위해 커널 프로세스의 권한이 필요하다.  

#### DKOM(Direct Kernel Object Manipulation  
DKOM 기법은 커널 오브젝트(EPROCESS)를 수정하여 프로세스를 숨기는 방법으로, 정상적인 프로세스 원형 이중 연결 리스트에서 숨기고자 하는 프로세스를 연결 리스트에서 빼내는 것이다.  
이렇게 하면 일반적으로 ActiveProcessLink를 참조하여 프로세스 목록을 얻는 도구들은 숨겨진 프로세스를 찾을 수 없다.  
일반적인 프로세스 순환 구조라면 [그림 2.70]이 되겠지만, 해커나 악의적인 루트킷에 의해 프로세스가 숨겨졌다면 [그림 2.71]과 같은 구조가 된다.  
![ListAfterRootKit](https://github.com/RaGoon1222/antirootDigitalForensic/blob/master/week_1/img/ProcessAfterRootKit.PNG?raw=true)  
숨겨진 프로세스는 자신을 가리키도록 만드는데 이렇게 하는 이유는 숨겨진 프로세스에 의해 BSOD가 일어나지 않게 하기 위해서이다.  
커널이 프로세스를 관리하기 위해 참조하는 ActiveProcessLink에서 제외되면 커널의 관리를 받지 못하므로 프로세스가 종료되거나 해야하는데 종료되지 않는 이유는 무엇일까?  

숨겨진 해당 프로세스가 점유하고 있는 자원이 회수되지 않고 메모리에 그대로 남기 때문에 프로세스는 생존할 수 있다.  
또한 윈도우는 프로세스 단위가 아닌 스레드 단위로 처리 기준을 정해놨기 때문에 프로세스가 종료되더라도 스레드만 살아있으면 얼마든지 어떠한 행위의 동작이 가능하다.  
이제는 이러한 지식을 바탕으로 메모리 덤프파일에서 프로세스를 찾는 방법을 알아보도록 한다.  
프로세스를 찾는 방법은 리스트 워킹 방법과, 패턴 매칭 방법이 있다.  

#### 커널 오브젝트 검색 방법
